"""
Base strategy abstract class for the Hybrid Regime-Switching Trading Bot.
All strategies must inherit from this class.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Optional

import pandas as pd


class SignalType(Enum):
    """Trading signal types."""
    LONG = "LONG"
    SHORT = "SHORT"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    signal_type: SignalType
    entry_price: float
    stop_loss: float
    reason: str
    indicators: dict


@dataclass
class PositionInfo:
    """Information about an open position."""
    trade_id: int
    symbol: str
    side: str  # 'LONG' or 'SHORT'
    entry_price: float
    size: float
    stop_loss: float
    trailing_stop: Optional[float] = None
    paper_position_id: Optional[int] = None  # For paper trading balance tracking


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Each strategy must implement:
    - check_entry_signal: Analyze data and return a Signal if conditions are met
    - check_exit_signal: Determine if an open position should be closed
    - calculate_stop_loss: Calculate the stop loss price for a new position
    """
    
    def __init__(self, name: str, timeframe: str):
        """
        Initialize the strategy.
        
        Args:
            name: Strategy identifier (e.g., 'MEAN_REVERSION', 'TREND_SNIPER')
            timeframe: Trading timeframe (e.g., '15m', '1h')
        """
        self.name = name
        self.timeframe = timeframe
    
    @abstractmethod
    def check_entry_signal(self, df: pd.DataFrame) -> Optional[Signal]:
        """
        Analyze market data and check for entry conditions.
        
        Args:
            df: DataFrame with OHLCV data and calculated indicators
        
        Returns:
            Signal object if entry conditions are met, None otherwise
        """
        pass
    
    @abstractmethod
    def check_exit_signal(
        self,
        df: pd.DataFrame,
        position: PositionInfo,
        current_price: float
    ) -> tuple[bool, str]:
        """
        Check if an open position should be closed.
        
        Args:
            df: DataFrame with OHLCV data and calculated indicators
            position: Current open position information
            current_price: Current market price
        
        Returns:
            Tuple of (should_exit: bool, reason: str)
        """
        pass
    
    @abstractmethod
    def calculate_stop_loss(
        self,
        df: pd.DataFrame,
        signal_type: SignalType,
        entry_price: float
    ) -> float:
        """
        Calculate stop loss price for a new position.
        
        Args:
            df: DataFrame with OHLCV data and calculated indicators
            signal_type: LONG or SHORT
            entry_price: Expected entry price
        
        Returns:
            Stop loss price
        """
        pass
    
    @abstractmethod
    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate all required technical indicators for this strategy.
        
        Args:
            df: DataFrame with OHLCV data
        
        Returns:
            DataFrame with added indicator columns
        """
        pass
    
    def get_latest_values(self, df: pd.DataFrame) -> dict:
        """
        Get the latest indicator values for logging.
        
        Args:
            df: DataFrame with calculated indicators
        
        Returns:
            Dictionary of indicator name -> value
        """
        latest = df.iloc[-1]
        return {col: latest[col] for col in df.columns if col not in ['open', 'high', 'low', 'close', 'volume']}
